DevOps Homework-08 by Eugeny Kobushka
-------------------------------------

***
**Самостоятельное задание:**
1. Определите input переменную для приватного ключа, использующегося в определении подключения для провижинеров (connection);
2. Определите input переменную для задания зоны в ресурсе "google_compute_instance" "app". У нее должно быть значение по умолчанию;
3. Отформатируйте все конфигурационные файлы используя команду 
```bash
terraform fmt
```
4. Так как в репозиторий не попадет ваш terraform.tfvars, то нужно сделать рядом файл terraform.tfvars.example, в котором будут указаны переменные для образца.

Указанное выше самостоятельное задание - выполнено. В переменные вынес все что посчитал нужным вынести. Заодно разбирался в процессе с созданием переменных.<br><br>
С созданием переменных разобрался. Они могут быть с несколькими вариантами значений: значение по дефолту, пользовательское значение и не иметь значения. Если мы значение не указали или терраформ по каким-то причинам не нашел значение переменной, то он попросит его ввести в момент создания инстанса. Значения переменных, как мы увидели выше, можно: 
* записать в файле variables.tf в виде дефолтных значений;
* записать в файле terraform.tfvars в виде пользовательских значений;
* записать в любой другой файл с расширением *.tf но тогда мы должны будем указать этот файл в опции запуска terraform -var-file=FILE;
* присвоить значение переменной в командной строке с помощью опции --var name=value;
* ввести в командной строке в процессе выполнения сценария терраформом;
* ну и наконец присвоить значения переменных через сценарий shell-скрипта в виде записей
  ```bash
  export TF_VAR_name=value
  ```
<br>

***
**Задание со звездочкой (1):**
* Опишите в коде терраформа добавление ssh ключа пользователя appuser1 в метаданные проекта. Выполните terraform apply и проверьте результат (публичный ключ можно брать пользователя appuser);
* Опишите в коде терраформа добавление ssh ключей нескольких пользователей в метаданные проекта (можно просто один и тот же публичный ключ, но с разными именами пользователей, например appuser1, appuser2 и т.д.). Выполните terraform apply и проверьте результат;
* Добавьте в веб интерфейсе ssh ключ пользователю appuser_web в метаданные проекта. Выполните terraform apply и проверьте результат;
* Какие проблемы вы обнаружили? Добавьте описание в README.md
* Не забудьте закоммитить добавленный код в репозиторий и добавить описание в README.md;

Добавление SSH-ключей в метаданные нашего проекта с помощью терраформа описывается следующим примитивом:

```bash
resource "google_compute_project_metadata" "infra" {
  metadata {
    ssh-keys = "$appuser1:${file("~/.ssh/appuser.pub")}appuser2:${file("~/.ssh/appuser.pub")}"
  }
}
```
При добавлении в веб-интерфейсе любых ключей они будут затерты и перезаписаны терраформом. Это является как плюсом, так и проблемой, так как накладывает ответственность на разработчика по сохранению ключей. Иначе они будут утеряны и придется заново проделать работу по добавлению их в проект. Когда проект состоит из нескольких человек - это не проблема, но если людей много, то это доставит много неприятных минут.


***
**Задание со звездочкой (2):**
* Опишите в коде terraform создание HTTP балансировщика, направляющего трафик на наше развернутое приложение на инстансе reddit-app. Проверьте доступность приложения по адресу балансировщика. Добавьте в output переменные адрес балансировщика;
* Добавьте в код еще один инстанс приложения, например reddit-app2, добавьте его в балансировщик и проверьте, что при остановке на одном из инстансов приложения (например systemctl stop puma), приложение продолжает быть доступным по адресу балансировщика; Добавьте в output переменные адрес второго инстанса;
* Не забудьте закоммитить добавленный код в репозиторий и добавить описание в README.md;
<br><br>
Чтобы описать в нашем проекте создание HTTP балансировщика, воспользуемся следующими ресурсами:

1. Создаем группу для наших инстансов, она описывается в примитиве **google_compute_instance_group** (в нашем случае группа состоит из дву инстансов).

2. Создаем правила по которым будут проверяться работоспособность наших инстансов, они описываются в примитиве **google_compute_http_health_check** (в нашем случае достаточно описать проверку наших инстансов по порту 9292).

3. Описываем бекенд нашего балансировщика в примитиве **google_compute_backend_service** - нам необходимо указать группу инстансов и по каким правилам мы проверяем работоспособность нашей группы.

4. Описываем правила по которым мы будет отправлять запросы на инстансы в нашей группе в примитиве **google_compute_url_map**

5. Создаем наш балансировщик в примитиве **google_compute_global_forwarding_rule** и указываем ему цели для работы в секции **google_compute_target_http_proxy**

<br>Описал создание балансировщика как я сам это понимаю. <br><br>
После создания второго инстанса и балансировщика для нашей группы инстансов, я проверил работу балансировщика.
<br>Все было корректно, кроме работы самого приложения. Оно не расчитано на работу через балансировщик и возникают проблемы со входом пользователям, так как балансировщик перекидывает нас с одного инстанса на другой...
<br><br>
Для удобства добавил в outputs.ft получение и вывод внешнего ip-адреса нашего балансера после создания.


<!-- Домашнее задание 06 завернул под кат -->
<br>

***
DevOps Homework-07 by Eugeny Kobushka
-------------------------------------
Замечания по пулл-реквесту исправил все...
<details><br>
***
**Задание:**
  * Создайте новую ветку в вашем репозитории для выполнения данного ДЗ.
  * Назовите ветку packer-base.
  * Перенесите наработки с предыдущего ДЗ в директорию config-scripts.
  * Создайте в infra репозитории директорию packer.
  * Внутри директории packer создайте файл ubuntu16.json
  * В случае успешного создания образа VM при помощи Packer закомитьте, результаты вашей работы в созданную ранее ветку.

***
**Самостоятельное задание:**<br>
1. Необходимо параметризировать созданный шаблон, используя пользовательские переменные (см. лекцию). Какие опции шаблона должны быть параметризированы:
  * ID проекта (обязательно)
  * source_image_family (обязательно)
  * machine_type
<br><br>"Обязательно" означает, что пользовательская переменная должна быть обязательна для определения и не иметь значения по умолчанию. Если вы будете создавать файл с переменными variables.json, то хорошей практикой считается внести его в .gitignore, а в репозиторий добавить файл variables.json.example с примером заполнения, используя вымышленные значения.

<br><details><br>

<span style="color:red">Здесь и далее мы находимся в каталоге packer и все команды исполняем в нем.</span>


Сборка образа с помощью packer используя наш шаблон. Рассмотрим несколько вариантов:
<br>**Вариант 1** - с помощью передачи переменных в строку packer для создания образа
```bash
packer build \
-var 'gcp_project_id=infra-188905' \
-var 'gcp_source_image_family=ubuntu-1604-lts' \
-var 'gcp_machine_type=f1-micro' ubuntu16.json
```
**Вариант 2** - с помощью передачи переменных в строку packer файлом variables.json (в качестве примера берем variables.json.example)
```bash
packer build -var-file="variables.json" ubuntu16.json
```
</details><br>

2. Исследовать другие опции builder для GCP
(ссылка). Какие опции точно хотелось бы видеть:
* Описание образа
* Размер и тип диска
* Название сети
* Теги

<br><details><br>
С опциями, указанными выше, я разобрался и добавил в шаблон parcker для создания образа. Нам интересна опция описания образа. Остальные опции фактически нужны только в процессе создания виртуальной машины. Мои выводы состоят в том, что скорее всего эти опции для Google Cloud Platform не нужны в образе.
</details><br>

***
**Задание со * первое:**
<br>Чтобы попрактиковать подход к управлению инфраструктурой Immutable infrastructure, о котором говорили на вебинаре, попробуйте “запечь” (bake) в образ VM все зависимости приложения и сам код приложения. 
<br>Результат должен быть таким: запускаем инстанс из созданного образа и на нем сразу же имеем запущенное приложение.
<br>Созданный шаблон должен называться **immutable.json** и содержаться в директории packer, image_family у
получившегося образа должен быть reddit-full. 
<br>Дополнительные файлы можно положить в директорию **packer/files**.

**Задание со * второе:**
<br>Для ускорения работы предлагается запускать виртуальную машину с помощью командной строки и утилиты gcloud.
<br>Создайте shell-скрипт с названием **create-reddit-vm.sh** в директории **config-scripts**. Запишите в него команду которая запустит виртуальную машину из образа подготовленного вами в рамках этого ДЗ, из семейства reddit-full, если вы выполнили первое задание со звездочкой, или reddit-base, если не выполняли.
<details>

<br>**Выполнение:**
<br> **Создание образа с помощью packer:**

<br>Выполнил данное задание в двух вариантах.
<br><br> * **Вариант 1:** создание полного образа с "запеченным" приложением через базовый образ.<br>
1. Создаем файл с переменными на основе шаблона variables.json
```json
{
    "gcp_project_id": "test-132681",
    "gcp_source_image_family": "ubuntu-1204-lts",
    "gcp_source_image_family_deploy_based": "reddit-base",
    "gcp_machine_type": "f1-micro"
}
```
* gcp_project_id - ID нашего проекта
* gcp_source_image_family - базовый дистрибутив Линукс на основе которого создаем наш образ
* gcp_source_image_family_deploy_based - имя нашего базового образа
* gcp_machine_type - тип создаваемого инстанса на GCP
<br><br>
2. Создаем базовый образ 
```bash
packer build -var-file="variables.json" ubuntu16.json
```
После выполнения будет создан пользовательский образ с установленными ruby, bundle, mongodb.

3. Создаем полный образ с приложением на основе нашего базового образа
```bash
packer build -var-file="variables.json" immutable.json
```

<br><br> * **Вариант 2:** создание полного образа без создания базового образа.<br>

* Создаем variables.json как описано выше
* Создаем полный образ
```bash
packer build -var-file="variables.json" immutable_full.json
```
<br>
После выполнения любого из описанных выше вариантов в образ будут интегрированы все необходимые пакеты и будет "запечено" наше приложение со всеми зависимостями.<br><br>


**Использование скрипта для создание инстанса:**
<br> Не стал мудрить и сделал скрипт в лоб. Можно переделать на вариант с передачей по крайней мере ID проекта в опциях, но так как предполагается, что скриптом будем пользоваться только мы и он будет создан раз и надолго, то вариант предложенный вполне подходит.
<br>Правим под себя переменные
```bash
PROJECT_NAME="test-132681"
IMAGE_FAMILY="reddit-full"
```
где, 
<br>**PROJECT_NAME** - это ID нашего проекта
<br>**IMAGE_FAMILY** - это наш образ с "запеченным" приложением на основе которого будет создан инстанс

<br>После выполнения скрипта будет выдана информация с адресами нашего инстанса. Заходим в браузере по адресу:<br>
http://EXTERNAL_IP:9292/

и видим работающее приложение...
</details>
</details>

<!-- Домашнее задание 06 завернул под кат -->
<br>

***

DevOps Homework-06 by Eugeny Kobushka (выполнено)
-------------------------------------
Замечания по пулл-реквесту исправил все...
<details><br>
***
**Задание:**
  * Создайте новую ветку Infra-2 в вашем репозитории в организации DevOps 2017-11 для выполнения данного ДЗ;
  * Добавьте, созданные в ходе работы скрипты в эту ветку;
  * Добавьте информацию о данном ДЗ в README.md;
  * Создайте Pull Request для ветки мастер и добавьте в ревьюверы Nklya
(Nikolay Antsiferov);
  * Добавьте "Labels" gcp и homework-06 к вашему Pull Request

Команды по настройке системы и деплоя приложения нужно завернуть в баш скрипты, чтобы не вбивать эти команды вручную:
* скрипт install_ruby.sh - должен содержать команды по установке руби;
* скрипт install_mongodb.sh - должен содержать команды по установке MongoDB;
* скрипт deploy.sh - должен содержать команды скачивания кода, установки зависимостей через bundler и запуск приложения.

**Дополнительное задание:**<br>
В качестве доп задания используйте созданные ранее
скрипты для создания Startup script, который будет
запускаться при создании инстанса. Передавать Startup
скрипт необходимо как доп опцию уже использованной
ранее команде gcloud. В результате применения данной
команды gcloud мы должны получать инстанс с уже
запущенным приложением. Startup скрипт необходимо
закомитить, а используемую команду gcloud вставить в
описание репозитория (README.md)

***
<details><br>
В ходе выполнения задания созданы скрипты:<br>
* **install_ruby.sh** - устанавливает руби и после установки выдает информацию о версии установленного ruby и bundle;
* **install_mongodb.sh** - устанавливает MongoDB и после выполнения показывает статус службы MongoDB;
* **deploy.sh** - скачивает из репозитория наше приложение, проверяет и устанавливает необходимые зависимости, и после выполнения показывает порт на котором выполняется наше приложение.

После создания виртуального хоста на Google Cloud Platform и получения IP-адреса можно выполнить полученные скрипты без копирования на удаленный сервер. Для этого выполняет следующие команды:
```bash
$ ssh -i ~/work/git/ssh-key-home05/ekobushka ekobushka@35.189.226.248 'bash -s' < ./install_ruby.sh
```
В случае успешного выполнения получим в выводе следующие строки:
```bash
   ruby 2.3.1p112 (2016-04-26) [x86_64-linux-gnu]
   Bundler version 1.11.2
```
Далее устанавливаем MongoDB таким же способом:
```bash
$ ssh -i ~/work/git/ssh-key-home05/ekobushka ekobushka@35.189.226.248 'bash -s' < ./install_mongodb.sh
```

В случае успешной установки в выводе получим статус установленной службы:
```bash
● mongod.service - High-performance, schema-free document-oriented database
   Loaded: loaded (/lib/systemd/system/mongod.service; enabled; vendor preset: enabled)
   Active: active (running) since Fri 2017-12-15 03:24:20 UTC; 236ms ago
     Docs: https://docs.mongodb.org/manual
 Main PID: 9573 (mongod)
   CGroup: /system.slice/mongod.service
           └─9573 /usr/bin/mongod --quiet --config /etc/mongod.conf

Dec 15 03:24:20 reddit-app systemd[1]: Started High-performance, schema-free document-oriented database.
```
Ну и последняя операция - деплой нашего приложения.
```bash
$ ssh -i ~/work/git/ssh-key-home05/ekobushka ekobushka@35.189.226.248 'bash -s' < ./deploy.sh
```
В случае успешного деплоя получим в выводе порт на котором работает наше приложение:
```bash
ekobush+ 10394  0.4  1.5 523624 26932 ?        Sl   03:52   0:00 puma 3.10.0 (tcp://0.0.0.0:9292) [reddit]
```
Открыв web-станичку нашего приложения убеждаемся что все работает...

На основе полученных скриптов создаем startup_script.sh который будем использовать для автоматического создания виртуального хоста полностью настроенного и готового к работе нашего приложения.

Чтобы использовать полученный скрипт нужно в команду gcloud добавить ключ --metadata и добавить наш скрипт прямо из репозитория. Полученная команда указана ниже:
```bash
gcloud compute instances create reddit-app\
  --boot-disk-size=10GB \
  --image-family ubuntu-1604-lts \
  --image-project=ubuntu-os-cloud \
  --machine-type=g1-small \
  --tags puma-server \
  --restart-on-failure \
  --zone=europe-west1-b \
  --metadata "startup-script-url=https://raw.githubusercontent.com/Otus-DevOps-2017-11/ekobushka_infra/Infra-2/startup_script.sh"
```
Для того чтобы использовать скрипт находящийся на локальном хосте, нужно использовать вместо опции startup-script-url использовать startup-script. Предыдущую команду нужно изменить в опции
```bash
--metadata-from-file startup-script=startup_script.sh
```
и запускать ее нужно в папке содержащей скрипт **startup_script.sh**

После выполнения данной команды получим соданный виртуальный хост с полностью рабочим приложением.

***
В процессе выполнения домашнего задания понадобился еще один скрипт, который готовит окружение на Debian-based системах. Этот скрипт установит все необходимые компоненты Google Cloud SDK и выполнит инициализацию
```bash
gcloud init
```
скрипт положил в папку environment/install_gcsdk.sh
<br>Туда же добавил environment/install_pumaserver.sh для создания инстанса на SCP
</details>
</details>

<!-- Домашнее задание 05 завернул под кат -->
<br>

***
DevOps Homework-05 by Eugeny Kobushka (выполнено)
-------------------------------------
Замечания в Readme.md исправил и собрал файлы этого задания в каталог homework-05-vpn...<br>
Обнаружил что тег "details" не работает в Microsoft Edge, а в Google Chrome работает.
<br><details><br>
### Создан стенд для домашнего задания:

**Hostame:** bastion
**Внешний IP:** 35.196.76.8, **Внутренний IP:** 10.142.0.2

**Hostname:** someinternalhost
**Внешний IP:** none, **Внутренний IP:** 10.142.0.3

***
**Задание:** Исследовать способ подключения к internalhost в одну команду из вашего рабочего устройства,
проверить работоспособность найденного решения и внести его в README.md в вашем репозитории
***
<br><details><br>
В моей версии ssh подключиться к хосту за бастионом можно с помощью команды:
```bash
ssh -J ekobushka@35.196.76.8 ekobushka@10.142.0.3
```
на старых версиях ssh -J (Jump host) не прокатит, нужно было использовать примерно такую строку
(вариантов туннелирования возможно несколько - это не единственный)
```bash
ssh -i ~/.ssh/ekobushka -A -o ProxyCommand='ssh -W %h:%p %r@35.196.76.8' ekobushka@someinternalhost
```
</details><br>

***
**Дополнительное задание:**

Предложить вариант решения для подключения из консоли при помощи команды вида **ssh internalhost** из локальной консоли рабочего устройства, чтобы подключение выполнялось по алиасу **internalhost** и внести его в README.md в вашем репозитории.
***
<br><details><br>
Чтобы упростить подключение к хостам нашего стенда для домашней работы нужно создать файл:
```bash
~/.ssh/config
```
или если он существует, то добавить в него следующие строки
```bash
Host bastion
  Hostname 35.196.76.8
  IdentityFile ~/.ssh/ekobushka
  User ekobushka

Host internalhost
  Hostname 10.142.0.3
  IdentityFile ~/.ssh/ekobushka
  ProxyJump bastion
  User ekobushka
```
</details>
</details>
